// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

library pub.lock_file;

import 'dart:async';

import 'package:yaml/yaml.dart';

import 'io.dart';
import 'package.dart';
import 'path_rep.dart';
import 'source_registry.dart';
import 'utils.dart';
import 'version.dart';

/// A parsed and validated `pubspec.lock` file.
class LockFile {
  /// The packages this lockfile pins.
  Map<String, PackageId> packages;

  LockFile._(this.packages);

  LockFile.empty()
    : packages = <String, PackageId>{};

  /// Loads a lockfile from [filePath].
  static Future<LockFile> load(PathRep filePath, SourceRegistry sources) {
    return readTextFile(filePath).then((text) =>
        LockFile._parse(filePath, text, sources));
  }

  /// Parses a lockfile whose text is [contents].
  factory LockFile.parse(String contents, SourceRegistry sources) {
    return LockFile._parse(null, contents, sources);
  }

  /// Parses the lockfile whose text is [contents].
  static LockFile _parse(PathRep filePath, String contents,
      SourceRegistry sources) {
    var packages = <String, PackageId>{};

    if (contents.trim() == '') return new LockFile.empty();
    var parsed = loadYaml(contents);

    var packageEntries = parsed['packages'];
    if (packageEntries != null) {
      packageEntries.forEach((name, spec) {
        // Parse the version.
        if (!spec.containsKey('version')) {
          throw new FormatException('Package $name is missing a version.');
        }
        var version = new Version.parse(spec['version']);

        // Parse the source.
        if (!spec.containsKey('source')) {
          throw new FormatException('Package $name is missing a source.');
        }
        var sourceName = spec['source'];

        if (!spec.containsKey('description')) {
          throw new FormatException('Package $name is missing a description.');
        }
        var description = spec['description'];

        // Parse the description if we know the source.
        if (sources.contains(sourceName)) {
          var source = sources[sourceName];
          description = source.parseDescription(filePath, description,
              fromLockFile: true);
        }

        var id = new PackageId(name, sourceName, version, description);

        // Validate the name.
        if (name != id.name) {
          throw new FormatException(
            "Package name $name doesn't match ${id.name}.");
        }

        packages[name] = id;
      });
    }

    return new LockFile._(packages);
  }

  /// Returns the serialized YAML text of the lock file.
  ///
  /// [packageDir] is the containing directory of the root package, used to
  /// properly serialize package descriptions.
  String serialize(PathRep packageDir, SourceRegistry sources) {
    // Convert the dependencies to a simple object.
    var data = {};
    packages.forEach((name, package) {
      var description = sources[package.source].serializeDescription(packageDir,
          package.description);

      data[name] = {
        'version': package.version.toString(),
        'source': package.source,
        'description': description
      };
    });

    return """
# Generated by pub
# See http://pub.dartlang.org/doc/glossary.html#lockfile
${yamlToString({'packages': data})}
""";
  }
}
