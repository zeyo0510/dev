T.StitchOperation=function(m,h){T.OperationBase.call(this,m,h);this.initIterations(10,[5,2,1,1,2,1,1,1,2,1],4,2);this.facesAdded=this.minHoleSizeSq=0;this.gapDistanceSet=this.gapDistanceUpdated=!1};T.StitchOperation.prototype=Object.create(T.OperationBase.prototype);T.StitchOperation.prototype.setGapDistance=function(m){this.gapDistance=m;this.gapDistanceSq=Math.pow(this.gapDistance,2);this.proximityDistanceSq=.01*this.gapDistanceSq;this.gapDistanceSet=!0};
T.StitchOperation.prototype.preOperate=function(m,h){T.GeometryUtils.resetGlobalBoundingBox(h)};
T.StitchOperation.prototype.preOperateObject=function(m,h){T.OperationBase.prototype.preOperateObject.call(this,m,h);h.newGeometry=h.geometry.clone();var l=h.newGeometry;this.facesAdded=0;if(l&&0!=l.faces.length){l.computeFaceNormals();l.computeBoundingBox();h.updateMatrixWorld();var t=this.getCurrentTopLevelObject();!this.gapDistanceSet&&t?(this.globalBB=T.GeometryUtils.getGlobalBoundingBox(t),m&&m.scene&&m.scene instanceof T.Platform&&m.scene.isPlatformVisible()&&0<m.scene.featureResolution?this.gapDistance=
Math.max(m.scene.featureResolution,m.scene.layerThickness):(t=this.globalBB.size(),this.gapDistance=Math.max(4E-4*Math.max(t.x,t.y,t.z),1E-4)),console.log("stitching gaps",this.gapDistance),this.gapDistanceSq=Math.pow(this.gapDistance,2),this.proximityDistanceSq=.01*this.gapDistanceSq,this.minHoleSizeSq=400*this.gapDistanceSq):this.globalBB=T.GeometryUtils.getGlobalBoundingBox(h);this.edgeFacesMap={};this.edges=[];this.vertexFaceMap={};this.vertexEdgeMap={};this.previousEdgesCount=Number.MAX_VALUE;
this.boundingSphereRadius=l.boundingBox?l.boundingBox.getBoundingSphere().radius:1E4}};T.StitchOperation.prototype.postOperateObject=function(m,h){var l=h.newGeometry;h.newGeometry=void 0;for(var t in this.vertexFaceMap)l.vertices[t].onBadEdge=void 0;l.mergeVertices();l.edgeFaceMap=void 0;l=new T.Mesh(l,h.material.clone());return T.OperationBase.prototype.postOperateMesh.call(this,m,h,l)};
T.StitchOperation.prototype.operateIteration=function(m,h){function l(b,c){void 0===d.vertexFaceMap[b]&&(d.vertexFaceMap[b]={});d.vertexFaceMap[b][c]=!0}function t(b,f){var a=T.GeometryUtils.getVertexReplacement(b,c);0>a&&(a=b,c.vertices[a].replacedBy=void 0);void 0===d.vertexEdgeMap[a]&&(d.vertexEdgeMap[a]=[]);d.vertexEdgeMap[a].push(f)}function R(b,c){var a=C(b,c);return 0==a.length?-1:a[0]}function C(b,f){hash=T.GeometryUtils.orderedKey(b,f);var a=d.edgeFacesMap[hash];if(void 0==a||0==a.length)return[];
var a=T.GeometryUtils.getVertexEdges(b,d.vertexEdgeMap,c),e=T.GeometryUtils.getVertexEdges(f,d.vertexEdgeMap,c);return a||e?a?e?a.filter(function(a){return-1!=e.indexOf(a)}):a:e:[]}function x(b,f){var a=T.GeometryUtils.getVertexEdges(b,d.vertexEdgeMap,c);if(a){for(var e=0,g=0;g<a.length;++g)a[e]=a[g],a[g]!=f&&++e;e!=a.length&&a.splice(e,a.length-e)}}function D(b,f){var a=d.vertexFaceMap[b];void 0!==a&&(void 0!==a[f]&&delete a[f],a=c.faces[f],a.borderClassification=void 0,a.traverseFrom=void 0)}function E(b,
f,a){if(c.vertices[b].equals(f))return!0;if(void 0!==a&&m.localToWorld(f.clone()).distanceToSquared(m.localToWorld(c.vertices[b].clone()))>a)return!1;a=d.vertexFaceMap[b];if(!a)return!1;for(var e in a)if(a=c.faces[e]){var g=new T.V3,k=new T.V3,h=a.a==b?f:c.vertices[a.a],v=a.b==b?f:c.vertices[a.b];g.subVectors(a.c==b?f:c.vertices[a.c],v);k.subVectors(h,v);g.cross(k);g.normalize();if(0>g.dot(a.normal)&&(0<k.lengthSq()&&0<g.lengthSq()||0<a.normal.lengthSq()))return!1}return!0}function U(b,f,a,e){b=d.edges[b];
if(!b||void 0!==a&&(void 0===e&&(e=b.line.closestPointToPoint(f,!0)),m.localToWorld(f.clone()).distanceToSquared(m.localToWorld(e.clone()))>a))return!1;a=c.faces[b.faceIndex];if(!a)return!1;var g=T.GeometryUtils.getOppositeFaceVertex(a,b.v1,b.v2);if(-1==g)return null;var k=T.GeometryUtils.getEdgeFaceDirection(a,b.v1,b.v2);if(0==k)return null;e=1==k?c.vertices[b.v2]:c.vertices[b.v1];g=c.vertices[g];b=T.GeometryUtils.calculateNormal(1==k?c.vertices[b.v1]:c.vertices[b.v2],f,g);f=T.GeometryUtils.calculateNormal(f,
e,g);return 0<=b.dot(a.normal)&&0<=f.dot(a.normal)}function V(b){var f=d.edges[b];if(!f)return null;b=T.GeometryUtils.getEdgePointSurfaceParameters(f.v1,c,d.edges,d.vertexEdgeMap,d.vertexFaceMap);f=T.GeometryUtils.getEdgePointSurfaceParameters(f.v2,c,d.edges,d.vertexEdgeMap,d.vertexFaceMap);if(!b&&!f)return null;var a=new T.V3,e=new T.V3,g=new T.V3,k=!1;b&&(a.add(b.weightedNormal),e.add(b.weightedDirection),g.add(b.weightedPerpendicular),k=k||b.flat);f&&(a.add(f.weightedNormal),e.add(f.weightedDirection),
g.add(f.weightedPerpendicular),k=k||f.flat);return{normal:a.normalize(),direction:e.normalize(),perpendicular:g.normalize(),flat:k}}function W(b,f,a,e,g){function k(a,c,d,e){return-1==a?U(b,c,d,e):E(a,c,d)}var h=S(a,d.edges[b],d.proximityDistanceSq),v,p,l,r,w=c.vertices[f];r=T.GeometryUtils.getEdgePointSurfaceParameters(f,c,d.edges,d.vertexEdgeMap,d.vertexFaceMap);-1!=h?(p=c.vertices[h],l=T.GeometryUtils.getEdgePointSurfaceParameters(h,c,d.edges,d.vertexEdgeMap,d.vertexFaceMap)):(p=a,l=V(b));if(r&&
l){var u=(new T.Plane).setFromNormalAndCoplanarPoint(r.normal,w),A=(new T.Plane).setFromNormalAndCoplanarPoint(l.normal,p),t=A.projectPoint(w),q=u.projectPoint(p),n,x=E(f,t,e)&&k(h,t,e,p),z=!1;!r.flat&&x?v=t:(z=E(f,q,e)&&k(h,q,e,p),!l.flat&&z&&(v=q));!v&&m.worldToLocal(t.clone()).distanceToSquared(m.worldToLocal(q.clone()))>1E-4*d.proximityDistanceSq&&(r.direction.setLength(d.boundingSphereRadius),l.direction.setLength(d.boundingSphereRadius),r=new T.Line3(w.clone().sub(r.direction),w.clone().add(r.direction)),
l=new T.Line3(p.clone().sub(l.direction),p.clone().add(l.direction)),A=A.intersectLine(r),u=u.intersectLine(l),A&&u&&(n=w.distanceTo(A),l=p.distanceTo(u),n=A.clone().multiplyScalar(n).add(u.clone().multiplyScalar(l)).divideScalar(n+l),m.worldToLocal(A.clone()).distanceToSquared(m.worldToLocal(u.clone()))<1E-4*d.proximityDistanceSq&&(u=A=null)),n&&E(f,n,e)&&k(h,n,e,p)?v=n:A&&E(f,A,e)&&k(h,A,e,p)?v=A:u&&k(h,u,e,p)&&E(f,u,e)&&(v=u));v||(x?v=t:z&&(v=q))}v||(E(f,p)?v=p:k(h,w,e,p)?v=w:g&&(h=S(a,d.edges[b],
16*d.proximityDistanceSq),v=-1==h?p:w));v&&(-1==h?X(f,v,b):Y(f,h,v))}function Y(b,f,a){a&&c.vertices[f].copy(a);if(a=d.vertexFaceMap[b])for(var e in a){a=c.faces[e];var g=T.GeometryUtils.faceContainsVertex(a,f);T.GeometryUtils.removeFaceFromEdgeFacesMap(e,c,d.edgeFacesMap);T.GeometryUtils.replaceFacePoint(a,b,f);if(g){a=a instanceof T.Face4?C(a.a,a.b).concat(C(a.b,a.c),C(a.c,a.d),C(a.d,a.a)):C(a.a,a.b).concat(C(a.b,a.c),C(a.c,a.a));for(g=0;g<a.length;++g){var k=d.edges[a[g]];z.removeEdge(c.vertices[k.v1],
c.vertices[k.v2],a[g]);x(k.v1,a[g]);x(k.v2,a[g]);k.removed=!0}a=e;g=c.faces[a];D(g.a,a);D(g.b,a);D(g.c,a);g instanceof T.Face4&&D(g.d,a)}else T.GeometryUtils.computeFaceNormal.call(c,a),T.GeometryUtils.addFaceToEdgeFacesMap(e,c,d.edgeFacesMap),l(f,e),D(b,e)}d.vertexFaceMap[b]=void 0;b=T.GeometryUtils.getVertexReplacement(b,c);f=T.GeometryUtils.getVertexReplacement(f,c);if(-1!=b&&-1!=f&&b!=f){if(e=d.vertexEdgeMap[b])for(a=0;a<e.length;++a)g=d.edges[e[a]],g.v1==b&&(g.v1=f,z.moveEdgePoint(c.vertices[g.v1],
c.vertices[g.v2],e[a],0,c.vertices[f])),g.v2==b&&(g.v2=f,z.moveEdgePoint(c.vertices[g.v1],c.vertices[g.v2],e[a],1,c.vertices[f])),t(f,e[a]);d.vertexEdgeMap[b]=void 0;c.vertices[b].replacedBy=f}}function S(b,d,a){var e=d.v1;d=d.v2;var g=b.distanceToSquared(c.vertices[e]);b=b.distanceToSquared(c.vertices[d]);return g<a&&b<a?g<b?e:d:g<a?e:b<a?d:-1}function X(b,f,a){var e=d.edges[a],g=e.v1,k=e.v2;c.vertices[b].copy(f);var h=R(b,k),m=R(g,b),p;p=e.faceIndex;var n=c.faces[p],r=n.clone();T.GeometryUtils.replaceFacePoint(r,
g,b);T.GeometryUtils.computeFaceNormal.call(c,r);r.borderClassification=2;var w=void 0,w=c.faces.length;c.faces.push(r);++d.facesAdded;var u=T.GeometryUtils.getOppositeFaceVertex(n,g,k);if(-1!=u&&u!=g&&u!=k)for(var u=C(k,u),q=0;q<u.length;++q){var y=d.edges[u[q]];y.faceIndex==p&&(y.removed=!0,x(y.v1,u[q]),x(y.v2,u[q]))}T.GeometryUtils.removeFaceFromEdgeFacesMap(p,c,d.edgeFacesMap);T.GeometryUtils.replaceFacePoint(n,k,b);T.GeometryUtils.computeFaceNormal.call(c,n);T.GeometryUtils.addFaceToEdgeFacesMap(p,
c,d.edgeFacesMap);void 0!==w?(T.GeometryUtils.addFaceToEdgeFacesMap(w,c,d.edgeFacesMap),D(k,p),l(k,w),k!=r.a&&l(r.a,w),k!=r.b&&l(r.b,w),k!=r.c&&l(r.c,w),void 0!==r.d&&k!=r.d&&l(r.d,w)):D(k,p);p=[p,w];if(void 0!=p[1])if(-1!=h&&-1!=m)z.removeEdge(c.vertices[g],c.vertices[k],a),x(g,a),x(k,a),e.removed=!0;else if(-1!=h)z.moveEdgePoint(c.vertices[e.v1],c.vertices[e.v2],a,1,c.vertices[b]),e.v2=b,e.edgeLengthSq=f.distanceToSquared(c.vertices[g]),e.line.end=c.vertices[b],t(b,a),x(k,a),removedEdge=d.edges[h],
x(removedEdge.v1,h),x(removedEdge.v2,h),removedEdge.removed=!0;else if(-1!=m)z.moveEdgePoint(c.vertices[e.v1],c.vertices[e.v2],a,0,c.vertices[b]),e.v1=b,e.edgeLengthSq=f.distanceToSquared(c.vertices[k]),e.line.start=c.vertices[b],e.faceIndex=p[1],t(b,a),x(g,a),removedEdge=d.edges[m],x(removedEdge.v1,h),x(removedEdge.v2,h),removedEdge.removed=!0;else{newEdge={v1:b,v2:k,edgeLengthSq:f.distanceToSquared(c.vertices[k]),faceIndex:p[1],line:new T.Line3(c.vertices[b],c.vertices[k])};h=d.edges.length;d.edges.push(newEdge);
z.insertEdge(c.vertices[newEdge.v1],c.vertices[newEdge.v2],h);z.moveEdgePoint(c.vertices[e.v1],c.vertices[e.v2],a,1,c.vertices[b]);e.v2=b;e.edgeLengthSq=f.distanceToSquared(c.vertices[g]);e.line.end=c.vertices[b];if(f=T.GeometryUtils.getVertexEdges(k,d.vertexEdgeMap,c))for(e=0;e<f.length;++e)f[e]==a&&(f[e]=h);t(b,h);t(b,a)}}var d=this,c=m.newGeometry;h=d.getIteration();0==h%4&&(T.RemoveSharpTrianglesOperation.removeSharpTrianglesIteration(m,d.edgeFacesMap,10*this.proximityDistanceSq,.01,.99,d.edges),
d.edgeFacesMap=T.GeometryUtils.updateEdgeFaces(c,!0));var L=Math.pow(d.gapDistance/d.iterations*(0==h?2:h+1),2);d.edges=[];this.vertexFaceMap={};d.vertexEdgeMap={};var z=new T.closestEdgeSearch(Math.sqrt(L),5E3,d.globalBB,m.matrixWorld),y,B,q,n,F,G,H,I,N=0,O;for(O in d.edgeFacesMap){if(d.cancelled)break;n=d.edgeFacesMap[O];q=T.GeometryUtils.getIndexesFromKey(O);y=q[0];B=q[1];F=0;if(n&&y!=B){if(0==n.length%2)for(q=1;q<n.length;++q)T.GeometryUtils.sameOrder(c.faces[n[0]],y,B)==T.GeometryUtils.sameOrder(c.faces[n[q]],
y,B)&&++F;q=c.vertices[y];I=c.vertices[B];if(1==n.length%2||2<=n.length&&n.length-2!=2*F){G=n[0];q.onBadEdge=h+1;I.onBadEdge=h+1;F=q.distanceToSquared(I);H=c.faces[G];var Z=T.GeometryUtils.getOppositeFaceVertex(H,y,B);H&&-1!=Z&&0!=F&&(z.insertEdge(q,I,d.edges.length),d.edges.push({v1:y,v2:B,edgeLengthSq:F,faceIndex:G,line:new T.Line3(c.vertices[y],c.vertices[B]),flippedNormals:0==n.length%2}),t(y,N),t(B,N),++N,T.GeometryUtils.traverseAdjacentFaces(G,c,d.edgeFacesMap,function(b,f,a,e){a=c.faces[b];
if(!a||a.traverseFrom==G||d.cancelled)return!1;a.traverseFrom=G;if(void 0!==f&&!T.GeometryUtils.faceContainsVertex(a,y)&&!T.GeometryUtils.faceContainsVertex(a,B))return!1;l(a.a,b);l(a.b,b);l(a.c,b);void 0!==a.d&&l(a.d,b);a.borderClassification=void 0===f?2:void 0==a.borderClassification?1:a.borderClassification;return!0}))}else q.onBadEdge!==h+1&&(q.onBadEdge=void 0),I.onBadEdge!==h+1&&(I.onBadEdge=void 0)}}if(0==d.edges.length)d.skipIterations(d.iterations-h-1);else if(1<h&&h<d.iterations-2&&d.previousEdgesCount<=
d.edges.length)d.skipIterations(d.iterations-3-h);else{d.previousEdgesCount=d.edges.length;var P,J,K=0,M=0;for(P in d.vertexEdgeMap){if(d.cancelled)break;void 0==c.vertices[P].processed&&T.GeometryUtils.traverseAdjacentVertexes(P,d.edges,d.vertexEdgeMap,c,function(b,f,a){var e=c.vertices[b];if(!e||void 0!==e.processed)return!1;e.processed=!0;var g=L,k,l,n=d.minHoleSizeSq,p=m.localToWorld(e.clone());z.traverseCloseEdges(e,Math.sqrt(L),function(a){var c=d.edges[a];if(c.removed||c.flippedNormals)return!1;
var f=c.line.closestPointToPoint(e,!0),h=m.localToWorld(f.clone());J=p.distanceToSquared(h);if(c.v1!=b&&c.v2!=b&&(J<n&&(n=J),J<g&&(g=J,k=a,l=f,0==J)))return!0});0==h&&0<n&&n!=d.minHoleSizeSq&&(K+=n,++M);void 0!==k&&W(k,b,l,L,h==d.iterations-1);return!0})}for(var Q in d.vertexFaceMap)if(c.vertices[Q].processed=void 0,c.vertices[Q].replacedBy=void 0,n=d.vertexFaceMap[Q])for(var aa in n)if(H=c.faces[aa])H.borderClassification=void 0,H.traverseFrom=void 0;0==h&&(this.gapDistanceSq/2<K/M?(console.log("update distance from ",
this.gapDistance.toFixed(4)," to ",Math.sqrt(K/M).toFixed(4)),this.gapDistanceSq=K/M,this.gapDistance=Math.sqrt(this.gapDistanceSq),this.proximityDistanceSq=.01*this.gapDistanceSq,this.gapDistanceUpdated=!0):d.skipIterations(1))}};
