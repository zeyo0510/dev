T.HoleFillerOperation=function(k,l){T.OperationBase.call(this,k,l);this.facesAdded=0;this.maxEdges=1E4;this.maxOptimizationIterations=5};T.HoleFillerOperation.prototype=Object.create(T.OperationBase.prototype);
T.HoleFillerOperation.prototype.operate=function(k,l){function f(a,c){void 0===b.vertexFaceMap[a]&&(b.vertexFaceMap[a]={});b.vertexFaceMap[a][c]=!0}function u(a,c){void 0===b.vertexEdgeMap[a]&&(b.vertexEdgeMap[a]=[]);b.vertexEdgeMap[a].push(c)}function v(c,d){var e=T.GeometryUtils.getVertexEdges(c,b.vertexEdgeMap,a);if(e){for(var f=0,h=0;h<e.length;++h)e[f]=e[h],e[h]!=d&&++f;f!=e.length&&e.splice(f,e.length-f)}}function r(b){b&&(b.boundingSphere=(new T.Sphere).setFromPoints([a.vertices[b.v],a.vertices[b.v1],
a.vertices[b.v2]]))}var b=this,n=T.GeometryUtils.cloneObject(k),a=n.geometry;this.facesAdded=0;if(a&&0!=a.faces.length){a.computeFaceNormals();a.computeBoundingBox();this.edges=[];this.edgesToOptimize=[];this.contourIndexes=[];this.vertexEdgeMap={};this.vertexFaceMap={};this.boundingSphereRadius=a.boundingBox?a.boundingBox.getBoundingSphere().radius:1E4;this.edgeFacesMap=T.GeometryUtils.updateEdgeFaces(a);var q,p,h,d,y,w,c,g=0,m;for(m in b.edgeFacesMap)if(d=b.edgeFacesMap[m],h=T.GeometryUtils.getIndexesFromKey(m),
q=h[0],p=h[1],d&&q!=p&&(h=a.vertices[q],c=a.vertices[p],1==d.length%2)){w=d[0];y=h.distanceToSquared(c);d=a.faces[w];var z=T.GeometryUtils.getOppositeFaceVertex(d,q,p);d&&-1!=z&&0!=y&&(b.edges.push({v1:q,v2:p,faceIndex:w,point1:h,point2:c}),u(q,g),u(p,g),++g,T.GeometryUtils.traverseAdjacentFaces(w,a,b.edgeFacesMap,function(c,d,e,h){e=a.faces[c];if(!e||e.traverseFrom==w||b.cancelled)return!1;e.traverseFrom=w;if(void 0!==d&&!T.GeometryUtils.faceContainsVertex(e,q)&&!T.GeometryUtils.faceContainsVertex(e,
p))return!1;f(e.a,c);f(e.b,c);f(e.c,c);void 0!==e.d&&f(e.d,c);return!0}))}T.GeometryUtils.traverseAdjacentVertexes(l,b.edges,b.vertexEdgeMap,a,function(c,d,e){d=a.vertices[c];if(!d||void 0!==d.processed)return!1;d.processed=!0;d.surfaceParameters=T.GeometryUtils.getEdgePointSurfaceParameters(c,a,b.edges,b.vertexEdgeMap,b.vertexFaceMap);r(d.surfaceParameters);b.contourIndexes.push(c);return!0});for(m=0;m<b.maxEdges&&2<b.contourIndexes.length;++m){g=function(b,c){var d=a.vertices[b].surfaceParameters,
f=a.vertices[c].surfaceParameters;if(f||d){if(!d)return-1;if(!f)return 1}else return 0;return d.boundaryAngle-f.boundaryAngle};d=indexOfMinElementMatchingCriteria(b.contourIndexes,g,function(c){var d=a.vertices[c].surfaceParameters,e;if(e=d){a:{e=d.v1;var d=d.v2,f=b.contourIndexes,h=Math.min(f.length,b.maxEdges),g,k;g=a.vertices[c].surfaceParameters;for(var l=a.vertices[c],m=a.vertices[e],n=a.vertices[d],r=g&&g.boundingSphere?g.boundingSphere:(new T.Sphere).setFromPoints([l,m,n]),q=0;q<h;++q){g=f[q];
var p=a.vertices[g].surfaceParameters;if(p&&p.boundingSphere&&(k=p.v1,g!=c&&k!=c&&r.intersectsSphere(p.boundingSphere))){if(g!=e&&g!=d&&T.GeometryUtils.pointAboveTriangle(a.vertices[g],l,m,n)){c=!0;break a}if(g!=e&&k!=e&&g!=d&&k!=d&&T.GeometryUtils.lineSegmentIntersectsTriangle(a.vertices[g],a.vertices[k],l,m,n)){c=!0;break a}}}c=!1}e=!c}return e});0>d&&(console.log("cant find good vertex to fill"),d=indexOfMinElementMatchingCriteria(b.contourIndexes,g,function(){return!0}));0>d&&(console.log("cant find any vertex to fill"),
d=0);h=b.contourIndexes[d];c=a.vertices[h].surfaceParameters;if(!c)break;b.edges[c.edgeIndex1].removed=!0;b.edges[c.edgeIndex2].removed=!0;v(c.v1,c.edgeIndex1);v(h,c.edgeIndex1);v(c.v2,c.edgeIndex2);v(h,c.edgeIndex2);b.contourIndexes.splice(b.contourIndexes.indexOf(h),1);var t=a.faces.length;d=new T.F3(h,c.v1,c.v2);T.GeometryUtils.computeFaceNormal.call(a,d);a.faces.push(d);g=b.edges.length;b.edges.push({v1:c.v1,v2:c.v2,faceIndex:t,point1:a.vertices[c.v1],point2:a.vertices[c.v2]});b.edgesToOptimize.push({v1:c.v1,
v2:c.v2});u(c.v1,g);u(c.v2,g);f(c.v1,t);f(c.v2,t);f(h,t);T.GeometryUtils.addFaceToEdgeFacesMap(t,a,b.edgeFacesMap);a.vertices[c.v1].surfaceParameters=T.GeometryUtils.getEdgePointSurfaceParameters(c.v1,a,b.edges,b.vertexEdgeMap,b.vertexFaceMap);a.vertices[c.v2].surfaceParameters=T.GeometryUtils.getEdgePointSurfaceParameters(c.v2,a,b.edges,b.vertexEdgeMap,b.vertexFaceMap);r(a.vertices[c.v1].surfaceParameters);r(a.vertices[c.v2].surfaceParameters)}for(g=0;g<b.maxOptimizationIterations;++g){m=h=0;for(c=
b.edgesToOptimize.length;m<c;++m)(d=b.edgesToOptimize[m])&&T.RemoveSharpTrianglesOperation.shouldFlipEdge(d.v1,d.v2,a,b.edgeFacesMap,null,null,.8)&&(d=T.RemoveSharpTrianglesOperation.flipEdge(d.v1,d.v2,a,b.edgeFacesMap,b.vertexFaceMap))&&(b.edgesToOptimize[m]={v1:d.v1,v2:d.v2},++h);if(0==h)break}for(var x in b.vertexFaceMap)if(a.vertices[x].processed=void 0,a.vertices[x].surfaceParameters=void 0,g=b.vertexFaceMap[x])for(t in g)if(d=a.faces[t])d.traverseFrom=void 0;editor.addObject(n,k.parent);editor.removeObject(k);
return n}};T.CreateBridgeOperation=function(k,l){T.OperationBase.call(this,k,l)};T.CreateBridgeOperation.prototype=Object.create(T.OperationBase.prototype);
T.CreateBridgeOperation.prototype.operate=function(k,l,f,u,v){var r=T.GeometryUtils.cloneObject(k),b=r.geometry,n=b.vertices,a=n.length;n.push(l);n.push(f);n.push(u);n.push(v);l=new T.F3(a+1,a+0,a+3);f=new T.F3(a+2,a+3,a+1);T.GeometryUtils.computeFaceNormal.call(b,l);T.GeometryUtils.computeFaceNormal.call(b,f);0>l.normal.dot(f.normal)&&(f.a=a+3,f.b=a+2,f.normal.negate());b.faces.push(l);b.faces.push(f);b.mergeVertices();editor.addObject(r,k.parent);editor.removeObject(k);return r};
