T.NO_SECTIONS=1E9;T.PackFloatToRGBA="vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}";T.PackFaceToRGBA="vec4 pack_face( const in float faceIndex, const in float objectIndex ) {\nfloat f1 = floor(faceIndex / 65536.0);\nfloat f2 = floor((faceIndex - 65536.0 * f1) / 256.0);\nfloat f3 = faceIndex - 65536.0 * f1 - 256.0 * f2;\nreturn vec4(f1 / 255.0, f2 / 255.0, f3 / 255.0, objectIndex / 255.0);\n}";
T.UnpackRGBAToFloat="float unpack_depth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 255.0 * 255.0 * 255.0 ), 1.0 / ( 255.0 * 255.0 ), 1.0 / 255.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}";T.PackFloatTo2HalfFloats="vec2 float_to_vec2( const in float f ) {\nreturn vec2(floor(f)/(256.0 * 16.0), fract(f));\n}";T.Unpack2HalfFloatsToFloat="float vec2_to_float( const in vec2 enc ) {\nreturn floor(fract(enc.x) * (256.0 * 16.0)) + floor(fract(enc.y) * 256.0 * 16.0) / (256.0 * 16.0);\n}";
T.PackNormalToFloat=[T.Unpack2HalfFloatsToFloat,"float pack_normal( const in vec3 n ) {\nvec2 enc = normalize(n.xy) * (sqrt(-n.z*0.5+0.5));\nenc = enc*0.5+0.5;\nreturn vec2_to_float(enc);\n}"].join("\n");T.UnpackFloatToNormal=[T.PackFloatTo2HalfFloats,"vec3 unpack_normal( const in float enc ) {\nvec4 nn = vec4(float_to_vec2(enc), 0.0, 0.0) * 2.0 + vec4(-1.0, -1.0, 1.0, -1.0);\nfloat l = dot(nn.xyz,-nn.xyw);\nnn.z = l;\nnn.xy *= sqrt(l);\nreturn nn.xyz * 2.0 + vec3(0.0, 0.0, -1.0);\n}"].join("\n");
T.DepthTestUniforms={tDiffuse:{type:"t",value:null},depthTest:{type:"i",value:0},screenWidth:{type:"f",value:0},screenHeight:{type:"f",value:0}};
T.DepthTestVertexShader=function(a,b){var c=["\nvarying float vNormal;",T.PackNormalToFloat,""].join("\n");return(a?"attribute float faceIndex;\nvarying float faceId;":"")+(b?c:"\nvarying vec3 vNormal;\n")+"varying vec4 vertexPosition;\nvarying vec4 mvPosition;\nvoid main() {\nvertexPosition = modelMatrix * vec4( position, 1.0 );\nmvPosition = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\ngl_Position = mvPosition;"+(a?"\nfaceId = faceIndex;":"")+(b?"\nvNormal = pack_normal(normalize( normalMatrix * normal ));\n":
"\nvNormal = normalize( normalMatrix * normal );\n")+"\n}\n"};T.DepthTestFragmentDefines="uniform sampler2D tDiffuse;\nuniform int depthTest;\nvarying vec4 mvPosition;\nvarying vec4 vertexPosition;\nuniform float screenWidth;\nuniform float screenHeight;";
T.DepthTestCutFragment=["if((cutMode[0] < "+T.NO_SECTIONS+" && float( vertexPosition.xyz[0] ) * float(cutMode[0]) < cutValue.x * float(cutMode[0]) )","|| (cutMode[1] < "+T.NO_SECTIONS+" && float( vertexPosition.xyz[1] ) * float(cutMode[1]) < cutValue.y * float(cutMode[1]) )","|| (cutMode[2] < "+T.NO_SECTIONS+" && float( vertexPosition.xyz[2] ) * float(cutMode[2]) < cutValue.z * float(cutMode[2]) ) )","{\ndiscard;\n}"].join("\n");
T.DepthTestByteInfoShader={uniforms:T.UniformsUtils.merge([T.DepthTestUniforms,{mode:{type:"i",value:0},objectId:{type:"i",value:0}}]),vertexShader:T.DepthTestVertexShader(!0,!1),fragmentShader:[T.DepthTestFragmentDefines,"uniform int mode;\nuniform int objectId;\nvarying vec3 vNormal;\nvarying float faceId;",T.PackFloatToRGBA,T.UnpackRGBAToFloat,T.PackFaceToRGBA,"void main() {\nvec2 vUv = (gl_FragCoord.xy) / vec2( screenWidth, screenHeight );\nfloat z = (1.0+mvPosition.z) * 0.5;\nconst float accuracy = 2.0/(255.0 * 255.0 * 255.0);\nvec4 texel = texture2D( tDiffuse, vUv );\nif (depthTest != 0 && texel == vec4(0.0)) discard;\nif (depthTest != 0 && z <= unpack_depth( texel ) + accuracy ) {\ndiscard;\n} else {\nif (mode == 0)\ngl_FragData[ 0 ] = pack_depth( z );\nelse if (mode == 1)\ngl_FragData[ 0 ] = vec4((vNormal + vec3(1.0)) * 0.5, 0.0);\nelse if (mode == 2)\ngl_FragData[ 0 ] = pack_face(faceId, float(objectId));\n}\n}"].join("\n")};
T.DepthTestFloatInfoShader={uniforms:T.UniformsUtils.merge([T.DepthTestUniforms,{objectId:{type:"i",value:0}}]),vertexShader:T.DepthTestVertexShader(!0,!0),fragmentShader:[T.DepthTestFragmentDefines,"uniform int objectId;\nvarying float vNormal;\nvarying float faceId;\nvoid main() {\nvec2 vUv = (gl_FragCoord.xy) / vec2( screenWidth, screenHeight );\nfloat z = (1.0+mvPosition.z) * 0.5;\nvec4 texel = texture2D( tDiffuse, vUv );\nif (depthTest != 0 && texel == vec4(0.0)) discard;\nif (depthTest != 0 && z <= texel.x) {\ndiscard;\n} else {\ngl_FragData[ 0 ] = vec4(z , vNormal, faceId, float(objectId));\n}\n}"].join("\n")};
T.ExtractFloatFaceShader={uniforms:{tDiffuse:{type:"t",value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D tDiffuse;\nvarying vec2 vUv;",T.PackFaceToRGBA,"void main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nif (texel == vec4(0))\ndiscard;\ngl_FragData[ 0 ] = pack_face(texel.z, texel.w);\n}"].join("\n")};
T.ComputeThicknessFromDepthShader={uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nvarying vec2 vUv;",T.UnpackRGBAToFloat,T.PackFloatToRGBA,"void main() {\nvec4 texel1 = texture2D( tDiffuse1, vUv );\nvec4 texel2 = texture2D( tDiffuse2, vUv );\nif (texel1.xyz == vec3(0) || texel2.xyz == vec3(0))\ndiscard;\nfloat distance = unpack_depth(texel2) - unpack_depth(texel1);\nif (distance > 0.0 )\ngl_FragColor = pack_depth(distance);\nelse\ngl_FragColor = vec4(1.0);\n}"].join("\n")};
T.CheckNegativeThicknessByteShader={uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nvarying vec2 vUv;",T.UnpackRGBAToFloat,"void main() {\nvec4 texel1 = texture2D( tDiffuse1, vUv );\nvec4 texel2 = texture2D( tDiffuse2, vUv );\nif (texel1.xyz == vec3(0) || texel2.xyz == vec3(0))\ndiscard;\nfloat distance = unpack_depth(texel2) - unpack_depth(texel1);\nif (distance > 0.0)\ngl_FragColor = vec4(0.0);\nelse\ngl_FragColor = vec4(1.0);\n}"].join("\n")};
T.CheckNegativeThicknessFloatShader={uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel1 = texture2D( tDiffuse1, vUv );\nvec4 texel2 = texture2D( tDiffuse2, vUv );\nif (texel1.xyz == vec3(0) || texel2.xyz == vec3(0))\ndiscard;\nfloat distance = texel2.x - texel1.x;\nif (distance > 0.0)\ngl_FragColor = vec4(0.0);\nelse\ngl_FragColor = vec4(1.0);\n}"};
T.ComputeThicknessCorrectionFromNormalShader={uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null},minAngle:{type:"f",value:.1},maxAngleDifference:{type:"f",value:.5}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform float minAngle;\nuniform float maxAngleDifference;\nuniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nvarying vec2 vUv;\n#define M_PI2 1.5707963267948966192313216916398\nfloat minCos = cos(M_PI2 - minAngle);\nfloat maxCos = cos(maxAngleDifference);\nbool isNan(float val) {\nreturn (val <= 0.0 || 0.0 <= val) ? false : true;\n}",
T.PackFloatToRGBA,"void main() {\nvec4 texel1 = texture2D( tDiffuse1, vUv );\nvec4 texel2 = texture2D( tDiffuse2, vUv );\nif (texel1.xyz == vec3(0) && texel2.xyz == vec3(0))\ndiscard;\nvec3 normal1 = normalize(texel1.xyz*2.0 - vec3(1.0));\nvec3 normal2 = normalize((texel2.xyz*2.0 - vec3(1.0))* -1.0);\nif (isNan(normal1.z)) normal1 = vec3(0.0, 0.0, 1.0);\nif (isNan(normal2.z)) normal2 = vec3(0.0, 0.0, 1.0);\nfloat angle1 = normal1.z;\nfloat angle2 = normal2.z;\nfloat avgAngle = (normal1.z + normal2.z) * 0.5;\nif (angle1 < minCos || angle2 < minCos || avgAngle < minCos || abs(dot(normal1, normal2)) < maxCos)\ndiscard;\nfloat correction = max(avgAngle, maxCos);\ngl_FragColor = pack_depth(correction);\n}"].join("\n")};
T.ApplyThicknessCorrectionShader={uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nvarying vec2 vUv;",T.UnpackRGBAToFloat,T.PackFloatToRGBA,"void main() {\nvec4 texel1 = texture2D( tDiffuse1, vUv );\nvec4 texel2 = texture2D( tDiffuse2, vUv );\nif (texel1.xyz == vec3(0))\ndiscard;\nelse if (texel2.xyz == vec3(0))\ngl_FragColor = vec4(1.0);\nelse {\nfloat distance = unpack_depth(texel1) * unpack_depth(texel2);\ngl_FragColor = pack_depth(distance);\n}\n}"].join("\n")};
T.ComputeThicknessFromDepthNormalShader={uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null},minAngle:{type:"f",value:.1},maxAngleDifference:{type:"f",value:.5}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform float minAngle;\nuniform float maxAngleDifference;\nuniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nvarying vec2 vUv;\n#define M_PI2 1.5707963267948966192313216916398\nfloat minCos = cos(M_PI2 - minAngle);\nfloat maxCos = cos(maxAngleDifference);\nbool isNan(float val) {\nreturn (val <= 0.0 || 0.0 <= val) ? false : true;\n}",
T.UnpackFloatToNormal,T.PackFloatToRGBA,"void main() {\nvec4 texel1 = texture2D( tDiffuse1, vUv );\nvec4 texel2 = texture2D( tDiffuse2, vUv );\nif (texel1.xyz == vec3(0) && texel2.xyz == vec3(0))\ndiscard;\nvec3 normal1 = unpack_normal(texel1.y);\nvec3 normal2 = unpack_normal(texel2.y)* -1.0;\nif (isNan(normal1.z)) normal1 = vec3(0.0, 0.0, 1.0);\nif (isNan(normal2.z)) normal2 = vec3(0.0, 0.0, 1.0);\nfloat angle1 = normal1.z;\nfloat angle2 = normal2.z;\nfloat avgAngle = (normal1.z + normal2.z) * 0.5;\nif (angle1 < minCos || angle2 < minCos || avgAngle < minCos || abs(dot(normal1, normal2)) < maxCos)\ngl_FragColor = vec4(1.0);\nelse {\nfloat distance = texel2.x - texel1.x;\ndistance *= max(avgAngle, maxCos);\ngl_FragColor = pack_depth(distance);\n}\n}"].join("\n")};
T.ComputeDepthDifferenceFromDepthNormalShader={uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nvarying vec2 vUv;",T.PackFloatToRGBA,"void main() {\nvec4 texel1 = texture2D( tDiffuse1, vUv );\nvec4 texel2 = texture2D( tDiffuse2, vUv );\nif (texel1.xyz == vec3(0) && texel2.xyz == vec3(0))\ndiscard;\nif (texel2.x > texel1.x)\ngl_FragColor = pack_depth(texel2.x - texel1.x);\nelse\ngl_FragColor = vec4(1.0);\n}"].join("\n")};
T.ExtractFloatDepthShader={uniforms:{tDiffuse:{type:"t",value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D tDiffuse;\nvarying vec2 vUv;",T.PackFloatToRGBA,"void main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nif (texel == vec4(0))\ndiscard;\ngl_FragData[ 0 ] = pack_depth(texel.x);\n}"].join("\n")};
