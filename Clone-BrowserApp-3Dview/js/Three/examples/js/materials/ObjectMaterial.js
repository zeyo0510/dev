T.NO_SECTIONS=1E9;T.ObjectMaterial=function(a){T.MeshPhongMaterial.call(this);this.cutMode=[T.NO_SECTIONS,T.NO_SECTIONS,T.NO_SECTIONS];this.cutValue=new T.V3(0,0,0);this.sliceMode=0;this.sliceValue=Infinity;this.setValues(a)};T.ObjectMaterial.outline=0;T.ObjectMaterial.prototype=Object.create(T.MeshPhongMaterial.prototype);
T.ObjectMaterial.prototype.clone=function(){var a=new T.ObjectMaterial;T.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.specular.copy(this.specular);a.shininess=this.shininess;a.metal=this.metal;a.perPixel=this.perPixel;a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.bumpMap=this.bumpMap;a.bumpScale=this.bumpScale;a.normalMap=this.normalMap;a.normalScale.copy(this.normalScale);
a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;a.fragmentShader=this.fragmentShader;
a.vertexShader=this.vertexShader;a.maxThickness=this.maxThickness;a.minThickness=this.minThickness;a.cutMode=this.cutMode.slice(0);a.cutValue=this.cutValue.clone();a.sliceMode=this.sliceMode;a.sliceValue=this.sliceValue;a.side=this.side;a.wireframe=this.wireframe;a.analysisMode=this.analysisMode;a.minThickness=this.minThickness;a.maxThickness=this.maxThickness;return a};
T.ShaderLib.object={uniforms:T.UniformsUtils.merge([T.UniformsLib.common,T.UniformsLib.bump,T.UniformsLib.normalmap,T.UniformsLib.fog,T.UniformsLib.lights,T.UniformsLib.shadowmap,{ambient:{type:"c",value:new T.Color(16777215)},emissive:{type:"c",value:new T.Color(0)},specular:{type:"c",value:new T.Color(1118481)},shininess:{type:"f",value:30},wrapRGB:{type:"v3",value:new T.V3(1,1,1)},cutValue:{type:"v3",value:new T.V3(0,0,0)},cutMode:{type:"iv1",value:[0,0,0]},outline:{type:"f",value:0},sliceMode:{type:"i",
value:0},sliceValue:{type:"f",value:0},analysisMode:{type:"i",value:0},minThickness:{type:"f",value:0},maxThickness:{type:"f",value:0}}]),vertexShader:["#define PHONG\nuniform float outline;\nuniform int analysisMode;\nuniform float minThickness;\nuniform float maxThickness;\nattribute vec2 vertexThickness;\nvarying vec4 vDepthColor;\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec4 vertexPosition;\nvarying float fuzz;",T.ShaderChunk.map_pars_vertex,T.ShaderChunk.lightmap_pars_vertex,
T.ShaderChunk.envmap_pars_vertex,T.ShaderChunk.lights_phong_pars_vertex,T.ShaderChunk.color_pars_vertex,T.ShaderChunk.morphtarget_pars_vertex,T.ShaderChunk.skinning_pars_vertex,T.ShaderChunk.shadowmap_pars_vertex,"void main() {\nvertexPosition = modelMatrix * vec4( position, 1.0 );\nfuzz = length( vertexPosition.xyz - cameraPosition.xyz ) / 512.0;",T.ShaderChunk.map_vertex,T.ShaderChunk.lightmap_vertex,T.ShaderChunk.color_vertex,T.ShaderChunk.morphnormal_vertex,T.ShaderChunk.skinbase_vertex,T.ShaderChunk.skinnormal_vertex,
T.ShaderChunk.defaultnormal_vertex,"vNormal = normalize( transformedNormal );",T.ShaderChunk.morphtarget_vertex,T.ShaderChunk.skinning_vertex,T.ShaderChunk.default_vertex,"vViewPosition = -mvPosition.xyz;",T.ShaderChunk.worldpos_vertex,T.ShaderChunk.envmap_vertex,T.ShaderChunk.lights_phong_vertex,T.ShaderChunk.shadowmap_vertex,"if (outline != 0.0) {\nvec4 viewPos = projectionMatrix * (modelViewMatrix * vec4( position + normal, 1.0 ));\nvec4 outlineNormal = normalize(viewPos - gl_Position);\ngl_Position = gl_Position + outlineNormal * outline * fuzz;\n}\nif (analysisMode != 0) {\nvDepthColor = vec4(0.0);\nif (analysisMode == 1 || analysisMode == 3) {\nif ( floor(vertexThickness.y) > 0.0 ) {\nfloat t = vertexThickness.x / floor(vertexThickness.y);\nfloat ratio = (t - minThickness) / (maxThickness - minThickness);\nvDepthColor = vec4(1.0-ratio, ratio, 0.0, 1.0);\n}\n}\nif (analysisMode == 2 || analysisMode == 3) {\nif (fract(vertexThickness.y) > 0.0) {\nvDepthColor.z = 1.0;\nif (vDepthColor.y >= 1.0) vDepthColor.y = 0.0;\n}\n}\n}\n}"].join("\n"),
fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nvarying vec4 vertexPosition;\nvarying float fuzz;\nuniform int cutMode[3];\nuniform vec3 cutValue;\nuniform float outline;\nuniform int sliceMode;\nuniform float sliceValue;\nuniform int analysisMode;\nuniform float minThickness;\nuniform float maxThickness;\nvarying vec4 vDepthColor;",T.ShaderChunk.color_pars_fragment,T.ShaderChunk.map_pars_fragment,
T.ShaderChunk.lightmap_pars_fragment,T.ShaderChunk.envmap_pars_fragment,T.ShaderChunk.fog_pars_fragment,T.ShaderChunk.lights_phong_pars_fragment,T.ShaderChunk.shadowmap_pars_fragment,T.ShaderChunk.bumpmap_pars_fragment,T.ShaderChunk.normalmap_pars_fragment,T.ShaderChunk.specularmap_pars_fragment,"void main() {\nif (analysisMode != 0) {\nif (vDepthColor.x <= 0.0 && vDepthColor.z == 0.0) discard;\ngl_FragColor = vDepthColor;\n} else {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );\n#ifdef DOUBLE_SIDED\nif (float( gl_FrontFacing ) < 1.0) {\ngl_FragColor.xyz = vec3(1.0, 0.0, 0.0);\n}\n#endif\n}",
T.ShaderChunk.map_fragment,T.ShaderChunk.alphatest_fragment,T.ShaderChunk.specularmap_fragment,T.ShaderChunk.lights_phong_fragment,"if (analysisMode == 0) {",T.ShaderChunk.lightmap_fragment,T.ShaderChunk.color_fragment,T.ShaderChunk.envmap_fragment,T.ShaderChunk.shadowmap_fragment,T.ShaderChunk.linear_to_gamma_fragment,T.ShaderChunk.fog_fragment,"#ifdef DOUBLE_SIDED\nif (float( gl_FrontFacing ) < 1.0) {\ngl_FragColor *= 1.4;\ngl_FragColor += vec4(0.1);\n}\n#endif\n} else {\ngl_FragColor = mix(gl_FragColor, vDepthColor, 0.6) * 1.2;\n}\nif (sliceMode != 0 && abs( mod (vertexPosition.xyz[2], sliceValue ) ) > fuzz) {\ndiscard;\n}",
"if((cutMode[0] < "+T.NO_SECTIONS+" && float( vertexPosition.xyz[0] ) * float(cutMode[0]) < cutValue.x * float(cutMode[0]) )","|| (cutMode[1] < "+T.NO_SECTIONS+" && float( vertexPosition.xyz[1] ) * float(cutMode[1]) < cutValue.y * float(cutMode[1]) )","|| (cutMode[2] < "+T.NO_SECTIONS+" && float( vertexPosition.xyz[2] ) * float(cutMode[2]) < cutValue.z * float(cutMode[2]) ) )","{\ndiscard;\n}\nif (outline != 0.0) {\ngl_FragColor = vec4( 1.0, 1.0, 0.0, 1.0 );","} else if ((cutMode[0] < "+T.NO_SECTIONS+
" && abs( vertexPosition.xyz[0] - cutValue.x ) < fuzz )","|| (cutMode[1] < "+T.NO_SECTIONS+" && abs( vertexPosition.xyz[1] - cutValue.y ) < fuzz )","|| (cutMode[2] < "+T.NO_SECTIONS+" && abs( vertexPosition.xyz[2] - cutValue.z ) < fuzz ) )","{\ngl_FragColor = vec4( 1, 0.0, 0.0, 1.0 );\n}\n}"].join("\n")};
