T.XrayMaterial=function(a){T.ShaderMaterial.call(this);this.depthWrite=this.depthTest=!1;this.blending=T.CustomBlending;this.blendDst=this.blendSrc=T.OneFactor;this.side=T.DoubleSide;this.setValues(T.XrayShader);this.setValues(a)};T.XrayMaterial.prototype=Object.create(T.ShaderMaterial.prototype);T.XrayMaterial.prototype.clone=function(){var a=new T.XrayMaterial;T.ShaderMaterial.prototype.clone.call(this,a);return a};
T.XrayShader={uniforms:{minZ:{type:"f",value:0},maxZ:{type:"f",value:1}},vertexShader:"varying vec4 mvPosition;\nvoid main() {\nmvPosition = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\ngl_Position = mvPosition;\n}",fragmentShader:"uniform float minZ;\nuniform float maxZ;\nvarying vec4 mvPosition;\nvoid main() {\nfloat flipNormal = ( 1.0 - 2.0 * float( gl_FrontFacing ) );\nfloat packed_value = ( mvPosition.z - minZ)/(maxZ-minZ);\ngl_FragData[ 0 ] = vec4 (vec3(packed_value * 1.0, packed_value * 1.0, packed_value * 1.0) * flipNormal, 1.0);\n}"};
T.XrayPackMaterial=function(a){T.ShaderMaterial.call(this);this.depthWrite=this.depthTest=!1;this.blending=T.CustomBlending;this.blendDst=this.blendSrc=T.OneFactor;this.blendEquation=T.AddEquation;this.setValues(T.XrayPackShader);this.setValues(a)};T.XrayPackMaterial.prototype=Object.create(T.ShaderMaterial.prototype);T.XrayPackMaterial.prototype.clone=function(){var a=new T.XrayPackMaterial;T.ShaderMaterial.prototype.clone.call(this,a);return a};
T.XrayPackShader={uniforms:{minZ:{type:"f",value:0},maxZ:{type:"f",value:1}},vertexShader:"varying vec4 mvPosition;\nvoid main() {\nmvPosition = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\ngl_Position = mvPosition;\n}",fragmentShader:"uniform float minZ;\nuniform float maxZ;\nvarying vec4 mvPosition;\nvec4 sparse_pack_depth( const in float d ) {\nfloat depth = (d + 1.0) * 0.5;\nconst vec4 bit_shift = vec4( 128.0 * 128.0 * 128.0, 128.0 * 128.0, 128.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 128.0, 1.0 / 128.0, 1.0 / 128.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\nfloat packed_value = ( mvPosition.z - minZ)/(maxZ-minZ);\ngl_FragData[ 0 ] = sparse_pack_depth( packed_value );\n}"};
T.XrayUnpackShader={uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nvarying vec2 vUv;\nfloat sparse_unpack_depth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 128.0 * 128.0 * 128.0 ), 1.0 / ( 128.0 * 128.0 ), 1.0 / 128.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\ndepth = depth * 2.0 - 1.0;\nreturn depth;\n}\nvoid main() {\nfloat depth1 = sparse_unpack_depth(texture2D( tDiffuse1, vUv ));\nfloat depth2 = sparse_unpack_depth(texture2D( tDiffuse2, vUv ));\nfloat packed_value = abs(depth2 - depth1);\ngl_FragData[ 0 ] = vec4 (vec3(packed_value * 1.0, packed_value * 1.0, packed_value * 1.0), 1.0);\n}"};
T.XrayCopyShader={uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\ngl_FragColor = vec4(min(texel.x, opacity * opacity), min(texel.y, opacity), min(texel.z, opacity), 1.0);\n}"};
